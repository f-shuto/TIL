# Iteratorパターン
ループを担当するクラスを独立させる
- Iteratorを使うことで、実装とは切り離して、数え上げを行うことができる。
```ruby
while it.next? do
  book = it.next
  puts book.name
end
# →　BookShelfの実装に依存しない
```
# Adapterパターン
- インターフェースに互換性のないクラス同士を組み合わせる
- 継承と委譲の２つの方法がある

# Template Methodパターン
- 親クラスで抽象メソッドを定義し、実際の実装はサブクラスでする
- ロジックを共通化できる
  - 抽象クラスの段階で処理の流れを形作る
- LSPの原則

# Factory Methodパターン
- インスタンスを生成する工場をTemplate Methodパターンで構成したもの
- インスタンス生成を担うメソッド（factory method）を通して間接的にオブジェクトを生成する
  - 直接`new Product()`としての生成より柔軟にオブジェクトを生成することができる

# Singletonパターン
- インスタンスが一個しか存在しないことを保証するパターン
- コンストラクタをprivateにし、別途インスタンスを取得するためのクラスメソッドを用意する

# Prototypeパターン
- インスタンスをコピーして新しいインスタンスを作る

# Builderパターン
- 構造を持ったインスタンスを組み上げていく

# Abstract Factoryパターン
- 部品の具体的な実装には注目せず、インターフェース（API）に注目する。そして、そのインターフェース（API）だけを使って、部品を組み立て、製品にまとめる。
- 組み立てるための具体的な実装は具象クラスで実装する。

# Bridgeパターン
- 「機能のクラスの階層」と「実装のクラスの階層」を橋渡しする
- 機能の階層と実装の階層を分けることで、機能の追加がしやすくなる

# Strategyパターン
- アルゴリズムの実装部分がごっそりと交換できるようになる
- アルゴリズムの実行は、採用したアルゴリズムに委譲する

# Compositeパターン
- コンピュータのファイルシステムのディレクトリとファイルのように、容器と中身を同一視、再帰的な構造を作るデザインパターン

# Decoratorパターン
- オブジェクトにどんどんデコレーションをほどこしていくようなデザインパターン
- 中身と飾り枠を同一視する

# Visitorパターン
- データ構造と処理を分離する
- データ構造の中をめぐり歩き処理をするVisitorクラスを用意する

# Chain of Responsibilityパターン
- たらい回し
- 複数のオブジェクトを鎖のようにつないでおき、そのオブジェクトの鎖を順次渡り歩いて目的のオブジェクトを決定する
- 「要求する側」と「処理する側」の結びつきを弱めることができる

# Facadeパターン
- 窓口
- インターフェースをシンプルにして複雑さを隠す

# Mediatorパターン
- 相談役
- メンバーは相談役を介す

# Observerパターン

# Mementoパターン

# Stateパターン